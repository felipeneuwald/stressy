// Package stressy provides CPU stress testing functionality through controlled
// worker goroutines that perform intensive cryptographic operations.
package stressy

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"golang.org/x/crypto/bcrypt"
)

// Stressy represents a CPU stress testing instance.
// It manages multiple worker goroutines that perform CPU-intensive operations
// and handles graceful shutdown through signals or timeouts.
type Stressy struct {
	workers int            // number of parallel worker goroutines
	timeout int           // duration in seconds (0 for indefinite)
	done    chan struct{} // channel for coordinating graceful shutdown
}

// Cfg holds the configuration parameters for creating a new Stressy instance.
type Cfg struct {
	Workers int // number of parallel worker goroutines
	Timeout int // duration in seconds (0 for indefinite)
}

// New creates and returns a new Stressy instance with the given configuration.
// The instance is ready to start but not yet running.
func New(c Cfg) *Stressy {
	return &Stressy{
		workers: c.Workers,
		timeout: c.Timeout,
		done:    make(chan struct{}),
	}
}

// Run starts the CPU stress test with the configured number of workers.
// It handles:
//   - Configuration validation
//   - Worker goroutine management
//   - Timer management (if timeout > 0)
//   - Signal handling (SIGINT, SIGTERM)
//   - Graceful shutdown
//
// The test runs until either:
//   - The timeout duration is reached (if configured)
//   - An interrupt signal is received
//
// Returns an error if the configuration is invalid.
func (s *Stressy) Run() error {
	if err := s.validateConfig(); err != nil {
		return err
	}

	fmt.Printf("Starting CPU stress test with %d workers", s.workers)
	if s.timeout > 0 {
		fmt.Printf(" for %d seconds\n", s.timeout)
	} else {
		fmt.Printf(" indefinitely\n")
	}
	fmt.Printf("Use --help for additional information\n")

	// Set up signal handling
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// Start CPU stress test goroutines
	for i := 0; i < s.workers; i++ {
		go s.stressTestCPU()
	}

	// Start timer if duration is set
	if s.timeout > 0 {
		go s.timer()
	}

	// Wait for either signal or timer
	select {
	case <-sigChan:
		fmt.Println("Received signal, shutting down...")
		close(s.done)
	case <-s.done:
		fmt.Println("Timer expired, shutting down...")
	}

	return nil
}

// validateConfig checks if the Stressy instance's configuration is valid.
// Returns an error if:
//   - workers is less than 1
//   - timeout is negative
func (s *Stressy) validateConfig() error {
	if s.workers < 1 {
		return fmt.Errorf("workers must be 1 or greater")
	}

	if s.timeout < 0 {
		return fmt.Errorf("timeout must be 0 (indefinite) or greater")
	}

	return nil
}

// timer manages the timeout duration for the stress test.
// It runs in its own goroutine and closes the done channel
// when the configured timeout is reached.
func (s *Stressy) timer() {
	timer := time.NewTimer(time.Duration(s.timeout) * time.Second)
	<-timer.C
	close(s.done)
}

// stressTestCPU performs CPU-intensive operations in a loop.
// It runs in its own goroutine and continues until the done
// channel is closed. The CPU load is generated by repeatedly
// computing bcrypt hashes with maximum cost.
func (s *Stressy) stressTestCPU() {
	for {
		select {
		case <-s.done:
			return
		default:
			_, err := bcrypt.GenerateFromPassword([]byte(fmt.Sprintf("%v", time.Now())), bcrypt.MaxCost)
			if err != nil {
				panic(err)
			}
		}
	}
}
